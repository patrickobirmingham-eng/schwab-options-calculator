<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schwab Transaction Data Sorter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .upload-section {
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #f0f0f0;
        }

        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-box:hover {
            background: #eef1ff;
            border-color: #764ba2;
        }

        .upload-box.dragover {
            background: #e0e7ff;
            border-color: #4338ca;
        }

        #fileInput {
            display: none;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .filters-section {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e0e0e0;
            display: none;
        }

        .filters-section.active {
            display: block;
        }

        .filters-title {
            font-size: 18px;
            font-weight: 700;
            color: #333;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .primary-filters {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            margin-bottom: 20px;
        }

        .primary-filters-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 15px;
        }

        .date-filter-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .date-range-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .secondary-filters {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .secondary-filters-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-size: 12px;
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .filter-group select,
        .filter-group input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            transition: border-color 0.2s;
        }

        .filter-group select:focus,
        .filter-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .filter-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 15px;
        }

        .reset-btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }

        .reset-btn:hover {
            background: #5568d3;
        }

        .active-filters-badge {
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .summary-section {
            padding: 20px 30px;
            background: #fff9e6;
            border-bottom: 2px solid #e0e0e0;
            display: none;
        }

        .summary-section.active {
            display: block;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .summary-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .summary-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }

        .table-section {
            padding: 30px;
            overflow-x: auto;
            display: none;
        }

        .table-section.active {
            display: block;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        thead {
            background: #667eea;
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            padding: 15px 12px;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background 0.2s;
        }

        th:hover {
            background: #5568d3;
        }

        th::after {
            content: '‚áÖ';
            position: absolute;
            right: 8px;
            opacity: 0.5;
            font-size: 12px;
        }

        th.sort-asc::after {
            content: '‚Üë';
            opacity: 1;
        }

        th.sort-desc::after {
            content: '‚Üì';
            opacity: 1;
        }

        tbody tr {
            border-bottom: 1px solid #e0e0e0;
            transition: background 0.2s;
        }

        tbody tr:hover {
            background: #f8f9ff;
        }

        tbody tr:nth-child(even) {
            background: #f9f9f9;
        }

        tbody tr:nth-child(even):hover {
            background: #f0f2ff;
        }

        td {
            padding: 12px;
        }

        .no-data {
            text-align: center;
            padding: 60px;
            color: #999;
            font-size: 16px;
        }

        .btn {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #5568d3;
        }

        @media (max-width: 768px) {
            .filters-grid {
                grid-template-columns: 1fr;
            }
            
            .summary-grid {
                grid-template-columns: 1fr;
            }

            table {
                font-size: 12px;
            }

            th, td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Schwab Transaction Data Sorter & Analyzer</h1>
            <p>Upload your Excel file to sort, filter, and analyze your data</p>
        </div>

        <div class="upload-section" id="uploadSection">
            <div class="upload-box" id="uploadBox">
                <div class="upload-icon">üìÅ</div>
                <h3>Click to upload or drag and drop</h3>
                <p>Supports .xlsx, .xls, .csv, and other spreadsheet files</p>
                <input type="file" id="fileInput" accept=".xlsx,.xls,.csv,*">
            </div>
        </div>

        <div class="filters-section" id="filtersSection">
            <div class="filters-title">
                üîç Filters
                <span class="active-filters-badge" id="activeFiltersBadge" style="display: none;">0</span>
            </div>
            
            <div class="primary-filters">
                <div class="primary-filters-grid">
                    <!-- Action Filter -->
                    <div class="filter-group">
                        <label for="actionFilter">Action</label>
                        <select id="actionFilter">
                            <option value="">All Actions</option>
                        </select>
                    </div>
                    
                    <!-- Date Filter Section -->
                    <div class="date-filter-section">
                        <div class="filter-group">
                            <label for="datePreset">Date Range Preset</label>
                            <select id="datePreset">
                                <option value="">Custom</option>
                                <option value="today">Today</option>
                                <option value="last7">Last 7 Days</option>
                                <option value="currentMonth">Current Month</option>
                                <option value="lastMonth">Last Month</option>
                                <option value="last3Months">Last 3 Months</option>
                                <option value="last6Months">Last 6 Months</option>
                                <option value="last12Months">Last 12 Months</option>
                                <option value="lastYear">Last Year</option>
                                <option value="currentYear">Current Year</option>
                            </select>
                        </div>
                        
                        <div class="date-range-inputs">
                            <div class="filter-group">
                                <label for="dateFrom">From</label>
                                <input type="date" id="dateFrom">
                            </div>
                            <div class="filter-group">
                                <label for="dateTo">To</label>
                                <input type="date" id="dateTo">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="secondary-filters">
                <div class="secondary-filters-title">Additional Filters</div>
                <div class="filters-grid" id="filtersGrid">
                    <!-- Secondary filters will be generated dynamically -->
                </div>
            </div>
            
            <div class="filter-actions">
                <button class="reset-btn" id="resetBtn">Reset All Filters</button>
                <button class="reset-btn" id="downloadBtn" style="background: #28a745;">Download Results</button>
            </div>
        </div>

        <div class="summary-section" id="summarySection">
            <div class="summary-grid" id="summaryGrid">
                <!-- Summary will be generated dynamically -->
            </div>
        </div>

        <div class="table-section" id="tableSection">
            <div id="tableContainer"></div>
        </div>
    </div>

    <script>
        let originalData = [];
        let currentData = [];
        let currentSort = { column: null, direction: null };
        let columnTypes = {};
        let dateColumn = null;
        let actionColumn = null;
        let amountColumn = null;

        const uploadBox = document.getElementById('uploadBox');
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const filtersSection = document.getElementById('filtersSection');
        const summarySection = document.getElementById('summarySection');
        const tableSection = document.getElementById('tableSection');
        const resetBtn = document.getElementById('resetBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const actionFilter = document.getElementById('actionFilter');
        const datePreset = document.getElementById('datePreset');
        const dateFrom = document.getElementById('dateFrom');
        const dateTo = document.getElementById('dateTo');
        const activeFiltersBadge = document.getElementById('activeFiltersBadge');

        // Upload box click handler
        uploadBox.addEventListener('click', () => fileInput.click());

        // Drag and drop handlers
        uploadBox.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadBox.classList.add('dragover');
        });

        uploadBox.addEventListener('dragleave', () => {
            uploadBox.classList.remove('dragover');
        });

        uploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadBox.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFile(file);
        });

        // File input change handler
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        // Reset button handler
        resetBtn.addEventListener('click', () => {
            currentData = [...originalData];
            currentSort = { column: null, direction: null };
            
            // Reset primary filters
            actionFilter.value = '';
            datePreset.value = '';
            dateFrom.value = '';
            dateTo.value = '';
            
            // Reset secondary filters
            const secondaryFilters = document.querySelectorAll('#filtersGrid select, #filtersGrid input');
            secondaryFilters.forEach(filter => {
                filter.value = '';
            });
            
            updateActiveFiltersCount();
            renderTable();
            updateSummary();
        });

        // Download button handler
        downloadBtn.addEventListener('click', () => {
            if (currentData.length === 0) {
                alert('No data to download');
                return;
            }
            
            // Create a new workbook
            const wb = XLSX.utils.book_new();
            
            // Convert current data to worksheet
            const ws = XLSX.utils.json_to_sheet(currentData);
            
            // Add worksheet to workbook
            XLSX.utils.book_append_sheet(wb, ws, 'Filtered Results');
            
            // Generate filename with timestamp
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `sorted_results_${timestamp}.xlsx`;
            
            // Download the file
            XLSX.writeFile(wb, filename);
        });

        // Action filter handler
        actionFilter.addEventListener('change', () => {
            applyFilters();
            updateActiveFiltersCount();
        });

        // Date preset handler
        datePreset.addEventListener('change', () => {
            if (datePreset.value) {
                const dateRange = getDateRangeFromPreset(datePreset.value);
                dateFrom.value = formatDateForInput(dateRange.from);
                dateTo.value = formatDateForInput(dateRange.to);
            }
            applyFilters();
            updateActiveFiltersCount();
        });

        // Manual date range handlers
        dateFrom.addEventListener('change', () => {
            if (dateFrom.value || dateTo.value) {
                datePreset.value = '';
            }
            applyFilters();
            updateActiveFiltersCount();
        });

        dateTo.addEventListener('change', () => {
            if (dateFrom.value || dateTo.value) {
                datePreset.value = '';
            }
            applyFilters();
            updateActiveFiltersCount();
        });

        function handleFile(file) {
            const reader = new FileReader();
            
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                    
                    if (jsonData.length === 0) {
                        alert('No data found in the Excel file.');
                        return;
                    }

                    originalData = jsonData;
                    currentData = [...originalData];
                    detectColumnTypes();
                    identifySpecialColumns();
                    populateActionFilter();
                    generateSecondaryFilters();
                    renderTable();
                    updateSummary();
                    updateActiveFiltersCount();
                    
                    filtersSection.classList.add('active');
                    summarySection.classList.add('active');
                    tableSection.classList.add('active');
                } catch (error) {
                    alert('Error reading file: ' + error.message);
                }
            };
            
            reader.readAsArrayBuffer(file);
        }

        function detectColumnTypes() {
            if (currentData.length === 0) return;
            
            const columns = Object.keys(currentData[0]);
            columnTypes = {};
            
            columns.forEach(col => {
                const sample = currentData.slice(0, 20).map(row => row[col]).filter(val => val != null && val !== '');
                
                if (sample.length === 0) {
                    columnTypes[col] = 'text';
                    return;
                }
                
                // Check if it's a number (but not a date number)
                const isNumber = sample.every(val => {
                    if (typeof val === 'number') {
                        // Check if it's likely an Excel date serial (typically between 1 and 50000 for recent dates)
                        if (val > 1 && val < 100000) {
                            const testDate = parseExcelDate(val);
                            if (testDate && testDate.getFullYear() > 1900 && testDate.getFullYear() < 2100) {
                                return false; // It's a date, not a regular number
                            }
                        }
                        return true;
                    }
                    const num = parseFloat(val);
                    return !isNaN(num) && val !== '';
                });
                
                if (isNumber) {
                    columnTypes[col] = 'number';
                    return;
                }
                
                // Check if it's a date
                let dateCount = 0;
                sample.forEach(val => {
                    const parsedDate = parseExcelDate(val);
                    if (parsedDate && !isNaN(parsedDate)) {
                        // Verify it's a reasonable date
                        const year = parsedDate.getFullYear();
                        if (year > 1900 && year < 2100) {
                            dateCount++;
                        }
                    }
                });
                
                if (dateCount > sample.length * 0.5) {
                    columnTypes[col] = 'date';
                    return;
                }
                
                columnTypes[col] = 'text';
            });
            
            console.log('Column types detected:', columnTypes);
        }

        function identifySpecialColumns() {
            const columns = Object.keys(currentData[0] || {});
            
            // Find Date column - prioritize columns with 'date' in the name
            dateColumn = columns.find(col => 
                col.toLowerCase() === 'date' || 
                col.toLowerCase().includes('date')
            );
            
            // If not found by name, find first column with date type
            if (!dateColumn) {
                dateColumn = columns.find(col => columnTypes[col] === 'date');
            }
            
            // Find Action column
            actionColumn = columns.find(col => 
                col.toLowerCase() === 'action' || 
                col.toLowerCase() === 'type' ||
                col.toLowerCase().includes('action') || 
                col.toLowerCase().includes('type')
            );
            
            // Find Amount column
            amountColumn = columns.find(col => 
                col.toLowerCase() === 'amount' ||
                col.toLowerCase() === 'price' ||
                col.toLowerCase() === 'value' ||
                col.toLowerCase().includes('amount') || 
                col.toLowerCase().includes('price') || 
                col.toLowerCase().includes('value')
            );
            
            console.log('Identified columns:', { dateColumn, actionColumn, amountColumn });
        }

        function populateActionFilter() {
            actionFilter.innerHTML = '<option value="">All Actions</option>';
            
            if (!actionColumn) return;
            
            const uniqueActions = [...new Set(
                originalData
                    .map(row => row[actionColumn])
                    .filter(val => val != null && val !== '')
            )].sort();
            
            uniqueActions.forEach(action => {
                const option = document.createElement('option');
                option.value = action;
                option.textContent = action;
                actionFilter.appendChild(option);
            });
        }

        function getDateRangeFromPreset(preset) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let from, to;
            
            switch(preset) {
                case 'today':
                    from = new Date(today);
                    to = new Date(today);
                    break;
                    
                case 'last7':
                    from = new Date(today);
                    from.setDate(today.getDate() - 6);
                    to = new Date(today);
                    break;
                    
                case 'currentMonth':
                    from = new Date(today.getFullYear(), today.getMonth(), 1);
                    to = new Date(today);
                    break;
                    
                case 'lastMonth':
                    from = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    to = new Date(today.getFullYear(), today.getMonth(), 0);
                    break;
                    
                case 'last3Months':
                    from = new Date(today);
                    from.setMonth(today.getMonth() - 3);
                    to = new Date(today);
                    break;
                    
                case 'last6Months':
                    from = new Date(today);
                    from.setMonth(today.getMonth() - 6);
                    to = new Date(today);
                    break;
                    
                case 'last12Months':
                    from = new Date(today);
                    from.setMonth(today.getMonth() - 12);
                    to = new Date(today);
                    break;
                    
                case 'lastYear':
                    from = new Date(today.getFullYear() - 1, 0, 1);
                    to = new Date(today.getFullYear() - 1, 11, 31);
                    break;
                    
                case 'currentYear':
                    from = new Date(today.getFullYear(), 0, 1);
                    to = new Date(today);
                    break;
                    
                default:
                    from = null;
                    to = null;
            }
            
            return { from, to };
        }

        function formatDateForInput(date) {
            if (!date) return '';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function generateSecondaryFilters() {
            const filtersGrid = document.getElementById('filtersGrid');
            filtersGrid.innerHTML = '';
            
            if (currentData.length === 0) return;
            
            const columns = Object.keys(currentData[0]);
            const excludedColumns = [dateColumn, actionColumn].filter(Boolean);
            
            columns.forEach(col => {
                // Skip primary filter columns
                if (excludedColumns.includes(col)) return;
                
                const filterGroup = document.createElement('div');
                filterGroup.className = 'filter-group';
                
                const label = document.createElement('label');
                label.textContent = col;
                filterGroup.appendChild(label);
                
                if (columnTypes[col] === 'number') {
                    const select = document.createElement('select');
                    select.innerHTML = `
                        <option value="">All</option>
                        <option value="positive">Positive</option>
                        <option value="negative">Negative</option>
                        <option value="zero">Zero</option>
                    `;
                    select.addEventListener('change', () => {
                        applyFilters();
                        updateActiveFiltersCount();
                    });
                    select.dataset.column = col;
                    select.dataset.type = 'number';
                    filterGroup.appendChild(select);
                } else if (columnTypes[col] === 'date') {
                    const input = document.createElement('input');
                    input.type = 'date';
                    input.addEventListener('change', () => {
                        applyFilters();
                        updateActiveFiltersCount();
                    });
                    input.dataset.column = col;
                    input.dataset.type = 'date';
                    filterGroup.appendChild(input);
                } else {
                    const uniqueValues = [...new Set(currentData.map(row => row[col]))].filter(val => val != null).slice(0, 50);
                    
                    if (uniqueValues.length > 0 && uniqueValues.length <= 20) {
                        const select = document.createElement('select');
                        select.innerHTML = '<option value="">All</option>' + 
                            uniqueValues.map(val => `<option value="${val}">${val}</option>`).join('');
                        select.addEventListener('change', () => {
                            applyFilters();
                            updateActiveFiltersCount();
                        });
                        select.dataset.column = col;
                        select.dataset.type = 'text';
                        filterGroup.appendChild(select);
                    } else {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.placeholder = 'Search...';
                        input.addEventListener('input', () => {
                            applyFilters();
                            updateActiveFiltersCount();
                        });
                        input.dataset.column = col;
                        input.dataset.type = 'text';
                        filterGroup.appendChild(input);
                    }
                }
                
                filtersGrid.appendChild(filterGroup);
            });
        }

        function applyFilters() {
            let filtered = [...originalData];
            
            console.log('Starting filters. Original data count:', filtered.length);
            
            // Apply Action filter
            if (actionColumn && actionFilter.value) {
                console.log('Applying action filter:', actionFilter.value);
                filtered = filtered.filter(row => row[actionColumn] == actionFilter.value);
                console.log('After action filter:', filtered.length);
            }
            
            // Apply Date range filter
            if (dateColumn && (dateFrom.value || dateTo.value)) {
                console.log('Applying date filter on column:', dateColumn);
                console.log('Date range:', dateFrom.value, 'to', dateTo.value);
                
                const fromDate = dateFrom.value ? new Date(dateFrom.value + 'T00:00:00') : null;
                const toDate = dateTo.value ? new Date(dateTo.value + 'T23:59:59') : null;
                
                console.log('Parsed dates:', fromDate, toDate);
                console.log('Sample date values from data:', filtered.slice(0, 5).map(r => ({
                    raw: r[dateColumn],
                    parsed: parseExcelDate(r[dateColumn])
                })));
                
                filtered = filtered.filter(row => {
                    const cellValue = row[dateColumn];
                    if (!cellValue) {
                        console.log('No cell value');
                        return false;
                    }
                    
                    const cellDate = parseExcelDate(cellValue);
                    if (!cellDate || isNaN(cellDate)) {
                        console.log('Invalid date:', cellValue);
                        return false;
                    }
                    
                    if (fromDate && cellDate < fromDate) return false;
                    if (toDate && cellDate > toDate) return false;
                    
                    return true;
                });
                
                console.log('After date filter:', filtered.length);
            }
            
            // Apply secondary filters
            const secondaryFilters = document.querySelectorAll('#filtersGrid select, #filtersGrid input');
            secondaryFilters.forEach(filter => {
                const column = filter.dataset.column;
                const type = filter.dataset.type;
                const value = filter.value;
                
                if (!value) return;
                
                filtered = filtered.filter(row => {
                    const cellValue = row[column];
                    
                    if (type === 'number') {
                        const num = parseFloat(cellValue);
                        if (value === 'positive') return num > 0;
                        if (value === 'negative') return num < 0;
                        if (value === 'zero') return num === 0;
                    } else if (type === 'date') {
                        const cellDate = parseExcelDate(cellValue);
                        const filterDate = new Date(value + 'T00:00:00');
                        if (!cellDate || !filterDate) return false;
                        return cellDate.toDateString() === filterDate.toDateString();
                    } else {
                        if (filter.tagName === 'SELECT') {
                            return cellValue == value;
                        } else {
                            return cellValue && cellValue.toString().toLowerCase().includes(value.toLowerCase());
                        }
                    }
                    return true;
                });
            });
            
            currentData = filtered;
            renderTable();
            updateSummary();
        }

        function parseExcelDate(value) {
            if (!value) return null;
            
            // If it's already a Date object
            if (value instanceof Date) {
                return value;
            }
            
            // If it's an Excel serial number (common in .xlsx files)
            if (typeof value === 'number') {
                // Excel serial date starts from January 1, 1900
                // Excel incorrectly treats 1900 as a leap year, so we need to account for that
                const excelEpoch = new Date(1899, 11, 30); // December 30, 1899
                const date = new Date(excelEpoch.getTime() + value * 86400000);
                return date;
            }
            
            // Try parsing as string
            if (typeof value === 'string') {
                // Try ISO format first
                let date = new Date(value);
                if (!isNaN(date)) return date;
                
                // Try parsing common date formats
                const formats = [
                    /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/, // MM/DD/YYYY or DD/MM/YYYY
                    /^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})$/, // YYYY/MM/DD
                    /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})$/  // MM/DD/YY
                ];
                
                for (let format of formats) {
                    const match = value.match(format);
                    if (match) {
                        date = new Date(value);
                        if (!isNaN(date)) return date;
                    }
                }
            }
            
            // Last resort: try direct conversion
            const date = new Date(value);
            return isNaN(date) ? null : date;
        }

        function updateActiveFiltersCount() {
            let count = 0;
            
            // Count primary filters
            if (actionFilter.value) count++;
            if (dateFrom.value || dateTo.value || datePreset.value) count++;
            
            // Count secondary filters
            const secondaryFilters = document.querySelectorAll('#filtersGrid select, #filtersGrid input');
            secondaryFilters.forEach(filter => {
                if (filter.value) count++;
            });
            
            if (count > 0) {
                activeFiltersBadge.textContent = count;
                activeFiltersBadge.style.display = 'inline-block';
            } else {
                activeFiltersBadge.style.display = 'none';
            }
        }

        function renderTable() {
            const tableContainer = document.getElementById('tableContainer');
            
            if (currentData.length === 0) {
                tableContainer.innerHTML = '<div class="no-data">No data to display</div>';
                return;
            }
            
            const columns = Object.keys(currentData[0]);
            
            let html = '<table><thead><tr>';
            columns.forEach(col => {
                const sortClass = currentSort.column === col ? 
                    (currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc') : '';
                html += `<th class="${sortClass}" onclick="sortTable('${col}')">${col}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            currentData.forEach(row => {
                html += '<tr>';
                columns.forEach(col => {
                    let value = row[col];
                    if (value == null) value = '';
                    
                    // Format numbers and dates
                    if (columnTypes[col] === 'number' && !isNaN(value)) {
                        value = parseFloat(value).toLocaleString(undefined, { 
                            minimumFractionDigits: 0, 
                            maximumFractionDigits: 2 
                        });
                    } else if (columnTypes[col] === 'date' && value) {
                        const date = parseExcelDate(value);
                        if (date && !isNaN(date)) {
                            value = date.toLocaleDateString();
                        }
                    }
                    
                    html += `<td>${value}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            tableContainer.innerHTML = html;
        }

        function sortTable(column) {
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                // Default sort direction based on type
                if (columnTypes[column] === 'number' || columnTypes[column] === 'date') {
                    currentSort.direction = 'desc'; // High to Low, Newest to Oldest
                } else {
                    currentSort.direction = 'asc'; // A to Z
                }
            }
            
            currentData.sort((a, b) => {
                let valA = a[column];
                let valB = b[column];
                
                // Handle null/undefined
                if (valA == null) return 1;
                if (valB == null) return -1;
                
                if (columnTypes[column] === 'number') {
                    valA = parseFloat(valA);
                    valB = parseFloat(valB);
                    return currentSort.direction === 'asc' ? valA - valB : valB - valA;
                } else if (columnTypes[column] === 'date') {
                    valA = parseExcelDate(valA);
                    valB = parseExcelDate(valB);
                    if (!valA) return 1;
                    if (!valB) return -1;
                    return currentSort.direction === 'asc' ? valA - valB : valB - valA;
                } else {
                    valA = valA.toString().toLowerCase();
                    valB = valB.toString().toLowerCase();
                    if (currentSort.direction === 'asc') {
                        return valA.localeCompare(valB);
                    } else {
                        return valB.localeCompare(valA);
                    }
                }
            });
            
            renderTable();
        }

        function updateSummary() {
            const summaryGrid = document.getElementById('summaryGrid');
            summaryGrid.innerHTML = '';
            
            if (currentData.length === 0) return;
            
            const columns = Object.keys(currentData[0]);
            
            // Box 1: Total Rows
            const rowCard = document.createElement('div');
            rowCard.className = 'summary-card';
            rowCard.innerHTML = `
                <div class="summary-label">Total Rows</div>
                <div class="summary-value">${currentData.length.toLocaleString()}</div>
            `;
            summaryGrid.appendChild(rowCard);
            
            // Box 2: Total Fees & Comm
            const feesCol = columns.find(col => col.toLowerCase().includes('fee') || col.toLowerCase().includes('comm'));
            let feesSum = 0;
            if (feesCol) {
                feesSum = currentData.reduce((acc, row) => {
                    const val = parseFloat(row[feesCol]);
                    return acc + (isNaN(val) ? 0 : val);
                }, 0);
            }
            
            const feesCard = document.createElement('div');
            feesCard.className = 'summary-card';
            feesCard.innerHTML = `
                <div class="summary-label">Total Fees & Comm</div>
                <div class="summary-value">${feesSum.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
            `;
            summaryGrid.appendChild(feesCard);
            
            // Box 3: Total Amount (furthest right)
            const amountCol = columns.find(col => col.toLowerCase().includes('amount'));
            let amountSum = 0;
            if (amountCol) {
                amountSum = currentData.reduce((acc, row) => {
                    const val = parseFloat(row[amountCol]);
                    return acc + (isNaN(val) ? 0 : val);
                }, 0);
            }
            
            const amountCard = document.createElement('div');
            amountCard.className = 'summary-card';
            amountCard.innerHTML = `
                <div class="summary-label">Total Amount</div>
                <div class="summary-value">${amountSum.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div>
            `;
            summaryGrid.appendChild(amountCard);
        }
    </script>
</body>
</html>
